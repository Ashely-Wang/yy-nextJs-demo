同步阻塞：一个函数执行完再执行下一个函数，并且在此过程中CPU不工作
同步非阻塞：一个函数执行完再执行下一个函数，并且在此过程中CPU工作
异步非阻塞：多个函数同时执行，并且CPU一直工作
异步阻塞：多个函数同时执行，
############################
进程之间所有的内存是隔离的
一般情况下开启的进程不超过CPU的两倍
因此，企图获取子进程返回值的想法是极其傻逼且荒谬的，因为父进程与子进程是隔离的
start方法就是一个典型的异步非阻塞
join就是同步阻塞
#############################
主进程必定是在所有的子进程结束之后再结束，以便为所有的子进程回收资源.
守护进程：在主进程的代码执行完毕后执行。
p.daemon()
（守护进程是在主进程的代码执行完之后再执行而不是在整个主进程结束后再执行！！！与其他的子进程无关）
############################
你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行
##############
celery本质就是两个大的生产者消费者模型
生产者消费者模型的应用场景：
爬虫
分布式操作
本质：让生产数据和消费数据的效率达到平衡并且最大化效率
######################
线程： 能被操作系统调度的(给CPU执行)的最小单位
数据共享
用一个进程中的多个线程可以同时被多个CPU执行
gc 垃圾回收机制
全局解释器锁GIL 主要是为了完成gc的回收机制，使其对不同线程的引用计数的变化更加准确，但也导致了CPU在同一时间只能执行一个线程，但这不并代表多线程不行，多线程省去了大部分I/O操作的时间.
进程可以用terminate函数强行中止，但是线程不能从外部关闭。
current_thread()获取当前线程
enumerate()获取当前所有线程
active_count()获取当前活跃的线程总数
